/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
        "context"
        "fmt"
        "strings"
        "time"

        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"

        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        karmadav1alpha1 "github.com/karmada-io/karmada/pkg/apis/policy/v1alpha1"
        migrationv1 "github.com/lehuannhatrang/stateful-migration-operator/api/v1"
)

const (
        // Label to mark resources as managed by checkpoint migration.
        CheckpointMigrationLabel = "checkpoint-migration.dcn.io"

        // Finalizer to ensure proper cleanup.
        MigrationBackupFinalizer = "migrationbackup.migration.dcnlab.com/finalizer"

        maxOrdinalsToProbe = 64
)

// MigrationBackupReconciler reconciles a StatefulMigration object.
type MigrationBackupReconciler struct {
        client.Client
        Scheme              *runtime.Scheme
        KarmadaClient       *KarmadaClient
        MemberClusterClient *MemberClusterClient
}

// +kubebuilder:rbac:groups=migration.dcnlab.com,resources=statefulmigrations,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=migration.dcnlab.com,resources=statefulmigrations/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=migration.dcnlab.com,resources=statefulmigrations/finalizers,verbs=update
// +kubebuilder:rbac:groups=migration.dcnlab.com,resources=checkpointbackups,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=migration.dcnlab.com,resources=checkpointbackups/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=deployments;statefulsets,verbs=get;list;watch;update;patch
// +kubebuilder:rbac:groups="",resources=pods,verbs=get;list;watch
// +kubebuilder:rbac:groups="",resources=namespaces,verbs=get;list;watch;create;update;patch
// +kubebuilder:rbac:groups="",resources=events,verbs=create;patch

// Reconcile moves the current state closer to the desired state.
func (r *MigrationBackupReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
        log := logf.FromContext(ctx)

        // Initialize Karmada client if not already done.
        if r.KarmadaClient == nil {
                karmadaClient, err := NewKarmadaClient()
                if err != nil {
                        log.Error(err, "Failed to initialize Karmada client")
                        // Without Karmada client, subsequent steps will fail. Requeue.
                        return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
                }
                r.KarmadaClient = karmadaClient
                log.Info("Successfully initialized Karmada client")

                // Initialize MemberClusterClient.
                if r.MemberClusterClient == nil {
                        memberClient, err := NewMemberClusterClient(r.KarmadaClient)
                        if err != nil {
                                log.Error(err, "Failed to initialize MemberClusterClient")
                                return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
                        }
                        r.MemberClusterClient = memberClient
                        log.Info("Successfully initialized MemberClusterClient")
                }
        }

        // Fetch the StatefulMigration instance.
        var statefulMigration migrationv1.StatefulMigration
        if err := r.Get(ctx, req.NamespacedName, &statefulMigration); err != nil {
                if apierrors.IsNotFound(err) {
                        log.Info("StatefulMigration resource not found. Ignoring since object must be deleted")
                        return ctrl.Result{}, nil
                }
                log.Error(err, "Failed to get StatefulMigration")
                return ctrl.Result{}, err
        }

        // Add finalizer if not present.
        if !controllerutil.ContainsFinalizer(&statefulMigration, MigrationBackupFinalizer) {
                controllerutil.AddFinalizer(&statefulMigration, MigrationBackupFinalizer)
                if err := r.Update(ctx, &statefulMigration); err != nil {
                        log.Error(err, "Failed to add finalizer")
                        return ctrl.Result{}, err
                }
        }

        // Handle deletion.
        if statefulMigration.GetDeletionTimestamp() != nil {
                return r.reconcileDelete(ctx, &statefulMigration)
        }

        // Handle normal reconciliation.
        return r.reconcileNormal(ctx, &statefulMigration)
}

// reconcileNormal handles the normal reconciliation logic.
func (r *MigrationBackupReconciler) reconcileNormal(ctx context.Context, sm *migrationv1.StatefulMigration) (ctrl.Result, error) {
        log := logf.FromContext(ctx)

        // A. 타깃 클러스터 결정
        targetCluster, err := r.determineTargetCluster(sm)
        if err != nil {
                log.Error(err, "cannot determine target cluster")
                return ctrl.Result{}, err
        }
        if r.MemberClusterClient == nil {
                return ctrl.Result{}, fmt.Errorf("member cluster client not initialized")
        }

        // B. 멤버(타깃)에서 대상 리소스 라벨링
        if err := r.addLabelToTargetResource(ctx, sm, targetCluster); err != nil {
                log.Error(err, "Failed to label target resource on member", "cluster", targetCluster)
                return ctrl.Result{}, err
        }

        // C. 멤버(타깃)에서 관련 Pod 수집
        pods, err := r.getPodsFromResourceRef(ctx, sm, targetCluster)
        if err != nil {
                log.Error(err, "Failed to get pods from member", "cluster", targetCluster)
                return ctrl.Result{}, err
        }

        // D. Karmada에 네임스페이스 보장 + 타깃 단일 클러스터 전파
        if err := r.ensureStatefulMigrationNamespace(ctx, sm, targetCluster); err != nil {
                log.Error(err, "Failed to ensure stateful-migration namespace")
                return ctrl.Result{}, err
        }

        // E. 타깃 클러스터에 CheckpointBackup CRD 보장
        if err := r.MemberClusterClient.EnsureCRD(ctx, targetCluster); err != nil {
                log.Error(err, "Failed to ensure CheckpointBackup CRD on cluster", "cluster", targetCluster)
                return ctrl.Result{}, err
        }

        // F. 각 Pod에 대해 CheckpointBackup + PropagationPolicy(Placement=타깃 클러스터)
        for _, pod := range pods {
                if err := r.reconcileCheckpointBackupForPod(ctx, sm, &pod, targetCluster); err != nil {
                        log.Error(err, "Failed to reconcile CheckpointBackup", "pod", pod.Name, "cluster", targetCluster)
                        return ctrl.Result{}, err
                }
        }

        // G. 고아 CheckpointBackup 정리(Karmada에서)
        if err := r.cleanupOrphanedCheckpointBackups(ctx, sm, pods); err != nil {
                log.Error(err, "Failed to cleanup orphaned CheckpointBackups")
                return ctrl.Result{}, err
        }

        log.Info("Reconciled StatefulMigration", "name", sm.Name, "targetCluster", targetCluster)
        return ctrl.Result{RequeueAfter: 5 * time.Minute}, nil
}

// ensureStatefulMigrationNamespace ensures the stateful-migration namespace exists on Karmada and is propagated to member clusters.
func (r *MigrationBackupReconciler) ensureStatefulMigrationNamespace(ctx context.Context, sm *migrationv1.StatefulMigration, targetCluster string) error {
        log := logf.FromContext(ctx)
        namespaceName := sm.Namespace
        if namespaceName == "" {
                return fmt.Errorf("StatefulMigration.metadata.namespace must be set")
        }

        if r.KarmadaClient == nil {
                return fmt.Errorf("Karmada client not initialized")
        }

        var existingNamespace corev1.Namespace
        err := r.KarmadaClient.Get(ctx, types.NamespacedName{Name: namespaceName}, &existingNamespace)
        if apierrors.IsNotFound(err) {
                log.Info("Creating namespace on Karmada", "namespace", namespaceName)
                ns := &corev1.Namespace{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: namespaceName,
                                Labels: map[string]string{
                                        "created-by":                "stateful-migration-operator",
                                        "app.kubernetes.io/name":    "stateful-migration",
                                        "app.kubernetes.io/part-of": "stateful-migration-operator",
                                },
                        },
                }
                if err := r.KarmadaClient.Create(ctx, ns); err != nil {
                        return fmt.Errorf("failed to create namespace %s on Karmada: %w", namespaceName, err)
                }
                log.Info("Successfully created namespace on Karmada", "namespace", namespaceName)
        } else if err != nil {
                return fmt.Errorf("failed to check namespace %s on Karmada: %w", namespaceName, err)
        } else {
                log.Info("Namespace already exists on Karmada", "namespace", namespaceName)
        }

        return r.ensureNamespacePropagationPolicy(ctx, namespaceName, targetCluster)
}

func (r *MigrationBackupReconciler) ensureNamespacePropagationPolicy(ctx context.Context, namespaceName, targetCluster string) error {
        log := logf.FromContext(ctx)
        policyName := namespaceName + "-propagation"

        existingPolicy := &karmadav1alpha1.PropagationPolicy{}
        err := r.KarmadaClient.Get(ctx, types.NamespacedName{
                Name: policyName, Namespace: namespaceName,
        }, existingPolicy)

        if apierrors.IsNotFound(err) {
                log.Info("Creating PropagationPolicy for namespace", "policy", policyName, "namespace", namespaceName)
                policy := &karmadav1alpha1.PropagationPolicy{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      policyName,
                                Namespace: namespaceName,
                                Labels: map[string]string{
                                        "created-by":                "stateful-migration-operator",
                                        "app.kubernetes.io/name":    "stateful-migration",
                                        "app.kubernetes.io/part-of": "stateful-migration-operator",
                                        "resource-type":             "namespace",
                                },
                        },
                        Spec: karmadav1alpha1.PropagationSpec{
                                ResourceSelectors: []karmadav1alpha1.ResourceSelector{{
                                        APIVersion: "v1", Kind: "Namespace", Name: namespaceName,
                                }},
                                Placement: karmadav1alpha1.Placement{
                                        ClusterAffinity: &karmadav1alpha1.ClusterAffinity{
                                                ClusterNames: []string{targetCluster},
                                        },
                                },
                        },
                }
                return r.KarmadaClient.CreateOrUpdatePropagationPolicy(ctx, policy)
        }
        if err != nil {
                return fmt.Errorf("failed to check PropagationPolicy %s: %w", policyName, err)
        }

        // 대상 클러스터가 다르면 업데이트
        needUpdate := true
        if existingPolicy.Spec.Placement.ClusterAffinity != nil {
                names := existingPolicy.Spec.Placement.ClusterAffinity.ClusterNames
                if len(names) == 1 && names[0] == targetCluster {
                        needUpdate = false
                }
        }
        if needUpdate {
                existingPolicy.Spec.Placement.ClusterAffinity = &karmadav1alpha1.ClusterAffinity{
                        ClusterNames: []string{targetCluster},
                }
                return r.KarmadaClient.Update(ctx, existingPolicy)
        }
        return nil
}

// reconcileDelete handles the deletion logic.
func (r *MigrationBackupReconciler) reconcileDelete(ctx context.Context, statefulMigration *migrationv1.StatefulMigration) (ctrl.Result, error) {
        log := logf.FromContext(ctx)

        // 타깃 클러스터 결정(실패해도 무시하고 계속)
        targetCluster, _ := r.determineTargetCluster(statefulMigration)
        if targetCluster != "" {
                _ = r.removeLabelFromTargetResource(ctx, statefulMigration, targetCluster)
        }

        // Delete all related CheckpointBackup resources.
        if err := r.deleteAllCheckpointBackups(ctx, statefulMigration); err != nil {
                log.Error(err, "Failed to delete CheckpointBackup resources")
                return ctrl.Result{}, err
        }

        // Remove finalizer.
        controllerutil.RemoveFinalizer(statefulMigration, MigrationBackupFinalizer)
        if err := r.Update(ctx, statefulMigration); err != nil {
                log.Error(err, "Failed to remove finalizer")
                return ctrl.Result{}, err
        }

        log.Info("Successfully deleted StatefulMigration", "name", statefulMigration.Name)
        return ctrl.Result{}, nil
}

func (r *MigrationBackupReconciler) addLabelToTargetResource(ctx context.Context, sm *migrationv1.StatefulMigration, cluster string) error {
        if r.MemberClusterClient == nil {
                return fmt.Errorf("member cluster client not initialized")
        }
        ref := sm.Spec.ResourceRef

        switch strings.ToLower(ref.Kind) {
        case "statefulset":
                sts, err := r.MemberClusterClient.GetStatefulSetFromCluster(ctx, cluster, ref.Namespace, ref.Name)
                if err != nil {
                        return err
                }
                if sts.Labels == nil {
                        sts.Labels = map[string]string{}
                }
                if sts.Labels[CheckpointMigrationLabel] != "true" {
                        sts.Labels[CheckpointMigrationLabel] = "true"
                        return r.MemberClusterClient.UpdateStatefulSetInCluster(ctx, cluster, sts)
                }
                return nil

        case "deployment":
                dep, err := r.MemberClusterClient.GetDeploymentFromCluster(ctx, cluster, ref.Namespace, ref.Name)
                if err != nil {
                        return err
                }
                if dep.Labels == nil {
                        dep.Labels = map[string]string{}
                }
                if dep.Labels[CheckpointMigrationLabel] != "true" {
                        dep.Labels[CheckpointMigrationLabel] = "true"
                        return r.MemberClusterClient.UpdateDeploymentInCluster(ctx, cluster, dep)
                }
                return nil

        case "pod":
                pod, err := r.MemberClusterClient.GetPodFromCluster(ctx, cluster, ref.Namespace, ref.Name)
                if err != nil {
                        return err
                }
                if pod.Labels == nil {
                        pod.Labels = map[string]string{}
                }
                if pod.Labels[CheckpointMigrationLabel] != "true" {
                        pod.Labels[CheckpointMigrationLabel] = "true"
                        return r.MemberClusterClient.UpdatePodInCluster(ctx, cluster, pod)
                }
                return nil

        default:
                return fmt.Errorf("unsupported resource kind: %s", ref.Kind)
        }
}

// 멤버(타깃)에서 라벨 제거
func (r *MigrationBackupReconciler) removeLabelFromTargetResource(ctx context.Context, sm *migrationv1.StatefulMigration, cluster string) error {
        if r.MemberClusterClient == nil {
                return nil
        }
        ref := sm.Spec.ResourceRef

        switch strings.ToLower(ref.Kind) {
        case "statefulset":
                sts, err := r.MemberClusterClient.GetStatefulSetFromCluster(ctx, cluster, ref.Namespace, ref.Name)
                if err != nil {
                        return err
                }
                if sts.Labels != nil {
                        delete(sts.Labels, CheckpointMigrationLabel)
                        return r.MemberClusterClient.UpdateStatefulSetInCluster(ctx, cluster, sts)
                }
                return nil

        case "deployment":
                dep, err := r.MemberClusterClient.GetDeploymentFromCluster(ctx, cluster, ref.Namespace, ref.Name)
                if err != nil {
                        return err
                }
                if dep.Labels != nil {
                        delete(dep.Labels, CheckpointMigrationLabel)
                        return r.MemberClusterClient.UpdateDeploymentInCluster(ctx, cluster, dep)
                }
                return nil

        case "pod":
                pod, err := r.MemberClusterClient.GetPodFromCluster(ctx, cluster, ref.Namespace, ref.Name)
                if err != nil {
                        return err
                }
                if pod.Labels != nil {
                        delete(pod.Labels, CheckpointMigrationLabel)
                        return r.MemberClusterClient.UpdatePodInCluster(ctx, cluster, pod)
                }
                return nil

        default:
                return fmt.Errorf("unsupported resource kind: %s", ref.Kind)
        }
}

// getPodsFromResourceRef gets all pods related to the resource reference.
func (r *MigrationBackupReconciler) getPodsFromResourceRef(ctx context.Context, sm *migrationv1.StatefulMigration, cluster string) ([]corev1.Pod, error) {
        if r.MemberClusterClient == nil {
                return nil, fmt.Errorf("member cluster client not initialized")
        }
        ref := sm.Spec.ResourceRef

        switch strings.ToLower(ref.Kind) {
        case "statefulset":
                sts, err := r.MemberClusterClient.GetStatefulSetFromCluster(ctx, cluster, ref.Namespace, ref.Name)
                if err != nil {
                        return nil, err
                }
                if sts.Spec.Selector == nil {
                        return nil, fmt.Errorf("statefulset %s/%s has nil .spec.selector", ref.Namespace, ref.Name)
                }
                sel, err := metav1.LabelSelectorAsSelector(sts.Spec.Selector)
                if err != nil {
                        return nil, err
                }
                return r.MemberClusterClient.ListPodsBySelector(ctx, cluster, ref.Namespace, sel)

        case "deployment":
                dep, err := r.MemberClusterClient.GetDeploymentFromCluster(ctx, cluster, ref.Namespace, ref.Name)
                if err != nil {
                        return nil, err
                }
                if dep.Spec.Selector == nil {
                        return nil, fmt.Errorf("deployment %s/%s has nil .spec.selector", ref.Namespace, ref.Name)
                }
                sel, err := metav1.LabelSelectorAsSelector(dep.Spec.Selector)
                if err != nil {
                        return nil, err
                }
                return r.MemberClusterClient.ListPodsBySelector(ctx, cluster, ref.Namespace, sel)

        case "pod":
                pod, err := r.MemberClusterClient.GetPodFromCluster(ctx, cluster, ref.Namespace, ref.Name)
                if err != nil {
                        return nil, err
                }
                return []corev1.Pod{*pod}, nil

        default:
                return nil, fmt.Errorf("unsupported resource kind: %s", ref.Kind)
        }
}

// getPodsFromSelector gets pods matching the given selector (management cluster fallback).
func (r *MigrationBackupReconciler) getPodsFromSelector(ctx context.Context, namespace string, selector *metav1.LabelSelector) ([]corev1.Pod, error) {
        labelSelector, err := metav1.LabelSelectorAsSelector(selector)
        if err != nil {
                return nil, err
        }
        var podList corev1.PodList
        if err := r.List(ctx, &podList, &client.ListOptions{
                Namespace:     namespace,
                LabelSelector: labelSelector,
        }); err != nil {
                return nil, err
        }
        return podList.Items, nil
}

// reconcileCheckpointBackupForPod creates or updates a CheckpointBackup for a specific pod and cluster.
func (r *MigrationBackupReconciler) reconcileCheckpointBackupForPod(
        ctx context.Context,
        statefulMigration *migrationv1.StatefulMigration,
        pod *corev1.Pod,
        cluster string,
) error {
        // Generate CheckpointBackup name.
        backupName := fmt.Sprintf("%s-%s-%s", statefulMigration.Name, pod.Name, cluster)

        // Create CheckpointBackup spec.
        backup := &migrationv1.CheckpointBackup{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      backupName,
                        Namespace: statefulMigration.Namespace,
                        Labels: map[string]string{
                                "stateful-migration": statefulMigration.Name,
                                "target-cluster":     cluster,
                                "target-pod":         pod.Name,
                        },
                },
                Spec: migrationv1.CheckpointBackupSpec{
                        Schedule: statefulMigration.Spec.Schedule,
                        PodRef: migrationv1.PodRef{
                                Namespace: pod.Namespace,
                                Name:      pod.Name,
                        },
                        ResourceRef: statefulMigration.Spec.ResourceRef,
                        Registry:    statefulMigration.Spec.Registry,
                        Containers:  r.extractContainerInfo(pod, statefulMigration.Spec.Registry),
                },
        }
        if backup.Labels == nil {
                backup.Labels = map[string]string{}
        }
        backup.Labels["stateful-migration"] = statefulMigration.Name

        // Create or update CheckpointBackup on Karmada control plane.
        if r.KarmadaClient == nil {
                return fmt.Errorf("Karmada client not initialized")
        }

        var existingBackup migrationv1.CheckpointBackup
        err := r.KarmadaClient.Get(ctx, types.NamespacedName{
                Name:      backupName,
                Namespace: statefulMigration.Namespace,
        }, &existingBackup)

        if apierrors.IsNotFound(err) {
                log := logf.FromContext(ctx)
                log.Info("Creating CheckpointBackup on Karmada",
                        "name", backupName, "namespace", statefulMigration.Namespace, "cluster", cluster)
                if err := r.KarmadaClient.Create(ctx, backup); err != nil {
                        return fmt.Errorf("failed to create CheckpointBackup on Karmada: %w", err)
                }
                log.Info("Successfully created CheckpointBackup on Karmada", "name", backupName)
        } else if err != nil {
                return fmt.Errorf("failed to check CheckpointBackup on Karmada: %w", err)
        } else {
                // Update existing CheckpointBackup on Karmada control plane.
                log := logf.FromContext(ctx)
                log.Info("Updating CheckpointBackup on Karmada",
                        "name", backupName, "namespace", statefulMigration.Namespace)
                existingBackup.Spec = backup.Spec
                if err := r.KarmadaClient.Update(ctx, &existingBackup); err != nil {
                        return fmt.Errorf("failed to update CheckpointBackup on Karmada: %w", err)
                }
                log.Info("Successfully updated CheckpointBackup on Karmada", "name", backupName)
        }

        // Create Karmada PropagationPolicy to distribute CheckpointBackup to target cluster.
        return r.createOrUpdatePropagationPolicy(ctx, backup, cluster)
}

// extractContainerInfo extracts container information from a pod.
func (r *MigrationBackupReconciler) extractContainerInfo(pod *corev1.Pod, registry migrationv1.Registry) []migrationv1.Container {
        var containers []migrationv1.Container
        for _, container := range pod.Spec.Containers {
                containers = append(containers, migrationv1.Container{
                        Name:  container.Name,
                        Image: fmt.Sprintf("%s:%s_%s", registry.Repository, pod.Name, container.Name),
                })
        }
        return containers
}

// createOrUpdatePropagationPolicy creates or updates a Karmada PropagationPolicy for the CheckpointBackup.
func (r *MigrationBackupReconciler) createOrUpdatePropagationPolicy(
        ctx context.Context,
        backup *migrationv1.CheckpointBackup,
        cluster string,
) error {
        log := logf.FromContext(ctx)

        // Skip if Karmada client is not available.
        if r.KarmadaClient == nil {
                log.Info("Skipping PropagationPolicy creation - Karmada client not available", "backup", backup.Name)
                return nil
        }

        policyName := fmt.Sprintf("%s-policy", backup.Name)

        policy := &karmadav1alpha1.PropagationPolicy{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      policyName,
                        Namespace: backup.Namespace,
                },
                Spec: karmadav1alpha1.PropagationSpec{
                        ResourceSelectors: []karmadav1alpha1.ResourceSelector{
                                {
                                        APIVersion: migrationv1.GroupVersion.String(), // 실제 CRD의 G/V 사용
                                        Kind:       "CheckpointBackup",
                                        Name:       backup.Name,
                                },
                        },
                        Placement: karmadav1alpha1.Placement{
                                ClusterAffinity: &karmadav1alpha1.ClusterAffinity{
                                        ClusterNames: []string{cluster},
                                },
                        },
                },
        }

        return r.KarmadaClient.CreateOrUpdatePropagationPolicy(ctx, policy)
}

// cleanupOrphanedCheckpointBackups removes CheckpointBackup resources that no longer have corresponding pods.
func (r *MigrationBackupReconciler) cleanupOrphanedCheckpointBackups(ctx context.Context, sm *migrationv1.StatefulMigration, currentPods []corev1.Pod) error {
        if r.KarmadaClient == nil {
                return fmt.Errorf("Karmada client not initialized")
        }
        var backupList migrationv1.CheckpointBackupList
        if err := r.KarmadaClient.List(ctx, &backupList, &client.ListOptions{
                Namespace: sm.Namespace,
                LabelSelector: labels.SelectorFromSet(map[string]string{
                        "stateful-migration": sm.Name,
                }),
        }); err != nil {
                return fmt.Errorf("failed to list CheckpointBackup resources on Karmada: %w", err)
        }

        currentPodNames := make(map[string]bool, len(currentPods))
        for _, pod := range currentPods {
                currentPodNames[pod.Name] = true
        }

        for _, backup := range backupList.Items {
                podName, exists := backup.Labels["target-pod"]
                if !exists || !currentPodNames[podName] {
                        if err := r.KarmadaClient.Delete(ctx, &backup); err != nil && !apierrors.IsNotFound(err) {
                                return fmt.Errorf("failed to delete CheckpointBackup %s/%s from Karmada: %w", backup.Namespace, backup.Name, err)
                        }
                }
        }
        return nil
}

func (r *MigrationBackupReconciler) deleteAllCheckpointBackups(ctx context.Context, sm *migrationv1.StatefulMigration) error {
        if r.KarmadaClient == nil {
                return fmt.Errorf("Karmada client not initialized")
        }
        var backupList migrationv1.CheckpointBackupList
        if err := r.KarmadaClient.List(ctx, &backupList, &client.ListOptions{
                Namespace: sm.Namespace,
                LabelSelector: labels.SelectorFromSet(map[string]string{
                        "stateful-migration": sm.Name,
                }),
        }); err != nil {
                return fmt.Errorf("failed to list CheckpointBackup resources on Karmada: %w", err)
        }

        log := logf.FromContext(ctx)
        for _, backup := range backupList.Items {
                log.Info("Deleting CheckpointBackup from Karmada", "name", backup.Name, "namespace", backup.Namespace)
                if err := r.KarmadaClient.Delete(ctx, &backup); err != nil && !apierrors.IsNotFound(err) {
                        return fmt.Errorf("failed to delete CheckpointBackup from Karmada: %w", err)
                }
        }
        return nil
}

// target-cluster 라벨 우선, 없으면 spec.sourceClusters[0] 폴백
func (r *MigrationBackupReconciler) determineTargetCluster(sm *migrationv1.StatefulMigration) (string, error) {
        if sm.Labels != nil {
                if c := sm.Labels["target-cluster"]; c != "" {
                        return c, nil
                }
        }
        if len(sm.Spec.SourceClusters) > 0 {
                return sm.Spec.SourceClusters[0], nil
        }
        return "", fmt.Errorf("target cluster not specified (metadata.labels['target-cluster'] 또는 spec.sourceClusters[0] 필요)")
}

// SetupWithManager sets up the controller with the Manager.
func (r *MigrationBackupReconciler) SetupWithManager(mgr ctrl.Manager) error {
        return ctrl.NewControllerManagedBy(mgr).
                For(&migrationv1.StatefulMigration{}).
                Owns(&migrationv1.CheckpointBackup{}).
                Named("migrationbackup").
                Complete(r)
}
